{
  "hash": "c5c9c029e74119e16740fc8af3260b19",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle:   \"Data Manipulation P1\"\ndate:    \"2024-07-15\"\nimage:   \"Featured_Image_Numpy.jpg\"\njupyter: python3\nfrom:    markdown+emoji\ncategories: [Numpy, Pandas, Polars, Modin, Vaex, Datatable, CuPy]\n---\n\n\n[`NumPy`](https://numpy.org/doc/stable/user/index.html#user) es una biblioteca fundamental para la computación científica en Python. Proporciona soporte para arreglos y matrices multidimensionales, junto con una colección de funciones matemáticas para operar con estos arreglos.\n\n::: {#a56cff32 .cell execution_count=1}\n``` {.python .cell-code}\n# pip install numpy\nimport numpy as np\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## *Creación de Arrays*\n\nBásicamente, hay cuatro tipos numéricos en el código NumPy, y cada uno puede tener algunos tamaños diferentes.\n\n| Name     | \\# of Bits | Python Type | NumPy Type   |\n|----------|------------|-------------|--------------|\n| Integer  | 64         | int         | np.int\\_     |\n| Booleans | 8          | bool        | np.bool\\_    |\n| Float    | 64         | float       | np.float\\_   |\n| Complex  | 128        | complex     | np.complex\\_ |\n\n::: {#809d5d65 .cell execution_count=2}\n``` {.python .cell-code}\n# Unidimensionales\na = np.array([1, 2, 3, 4, 5], dtype = 'float64'); print(a); print(a.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1. 2. 3. 4. 5.]\nfloat64\n```\n:::\n:::\n\n\n::: {#9f61328b .cell execution_count=3}\n``` {.python .cell-code}\n# Bidimensionales\nb = np.array([[1, 2, 3], [4, np.NaN, 6]]); print(b)\nprint(f'''\n  b.ndim : { b.ndim }\n  b.shape: { b.shape }\n  b.size : { b.size }\n''')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1.  2.  3.]\n [ 4. nan  6.]]\n\n  b.ndim : 2\n  b.shape: (2, 3)\n  b.size : 6\n\n```\n:::\n:::\n\n\n::: {#9029255a .cell execution_count=4}\n``` {.python .cell-code}\nnp.array([\"lunes\", \"martes\", \"miercoles\"], dtype = str).itemsize\n\ndata = np.array([\n  (\"joe\", 32, 6),\n  (\"mary\", 15, 20),\n  (\"felipe\", 80, 100),\n  (\"beyonce\", 38, 9001),\n], dtype=[(\"name\", str, 10), (\"age\", int), (\"power\", int)])\n\ndata[data[\"power\"] > 9000][\"name\"]\nnp.sort(data[data[\"age\"] > 20], order = \"power\")[\"name\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray(['joe', 'felipe', 'beyonce'], dtype='<U10')\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## *Arrays con Valores Iniciales Específicos*\n\n::: {#041d89f8 .cell execution_count=5}\n``` {.python .cell-code}\n# Array de ceros\nc = np.zeros((3, 4)); print(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n```\n:::\n:::\n\n\n::: {#f4041e12 .cell execution_count=6}\n``` {.python .cell-code}\n# Array de unos\nd = np.ones((2, 3)); print(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 1. 1.]\n [1. 1. 1.]]\n```\n:::\n:::\n\n\n::: {#840fe26c .cell execution_count=7}\n``` {.python .cell-code}\n# Matriz identidad\ne = np.eye(4); print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n```\n:::\n:::\n\n\n::: {#39ed5c64 .cell execution_count=8}\n``` {.python .cell-code}\n# Array de un valor constante\nf = np.full((3, 3), 7); print(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[7 7 7]\n [7 7 7]\n [7 7 7]]\n```\n:::\n:::\n\n\n::: {#802ab4a8 .cell execution_count=9}\n``` {.python .cell-code}\n# Array con valores aleatorios\ng = np.random.random((2, 2)); print(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0.25067324 0.02850246]\n [0.09238464 0.33715183]]\n```\n:::\n:::\n\n\n::: {#d1e28aed .cell execution_count=10}\n``` {.python .cell-code}\n# Array de un rango de valores\nh = np.arange(10, 20, 2); print(h)\nprint(np.arange(32).reshape(4, 1, 8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10 12 14 16 18]\n[[[ 0  1  2  3  4  5  6  7]]\n\n [[ 8  9 10 11 12 13 14 15]]\n\n [[16 17 18 19 20 21 22 23]]\n\n [[24 25 26 27 28 29 30 31]]]\n```\n:::\n:::\n\n\n::: {#39690e65 .cell execution_count=11}\n``` {.python .cell-code}\n# Array con un número específico de valores igualmente espaciados\ni = np.linspace(0, 1, 5); print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.   0.25 0.5  0.75 1.  ]\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## *Manipulación de Arrays*\n\n::: {#154348cb .cell execution_count=12}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\nprint(a[0])    # Primer elemento\nprint(a[1:3])  # Subarray del índice 1 al 2\nprint(a[-1])   # Último elemento\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n[2 3]\n5\n```\n:::\n:::\n\n\n::: {#228897e1 .cell execution_count=13}\n``` {.python .cell-code}\na = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(a[1, 2])      # Elemento en la fila 1, columna 2\nprint(a[:, 1])      # Todas las filas, segunda columna\nprint(a[1:3, 1:3])  # Subarray desde la fila 1 a 2 y columna 1 a 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n[2 5 8]\n[[5 6]\n [8 9]]\n```\n:::\n:::\n\n\n::: {#15960d24 .cell execution_count=14}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5])\na[0] = 10\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10  2  3  4  5]\n```\n:::\n:::\n\n\n::: {#de8cb4df .cell execution_count=15}\n``` {.python .cell-code}\na = np.array([1.1, 2.2])\na = np.append(a, [3.9, 4.6])\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1.1 2.2 3.9 4.6]\n```\n:::\n:::\n\n\n::: {#8b354582 .cell execution_count=16}\n``` {.python .cell-code}\na = np.insert(a, 1, values = [1.8, 2.0]); print(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1.1 1.8 2.  2.2 3.9 4.6]\n```\n:::\n:::\n\n\n::: {#fbf5283f .cell execution_count=17}\n``` {.python .cell-code}\na = np.delete(a, [1, 2]); print(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1.1 2.2 3.9 4.6]\n```\n:::\n:::\n\n\n::: {#627c75a1 .cell execution_count=18}\n``` {.python .cell-code}\na = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(a.ravel())          # Flatten the array\nprint(a.reshape((3, 2)))  # Reshape, but don’t change data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6]\n[[1 2]\n [3 4]\n [5 6]]\n```\n:::\n:::\n\n\n::: {#10fc4839 .cell execution_count=19}\n``` {.python .cell-code}\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nc = np.concatenate((a, b), axis = None)\nprint(c)\n\n# Dividir un array en múltiples subarrays\nd = np.split(c, 3)\nprint(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6]\n[array([1, 2]), array([3, 4]), array([5, 6])]\n```\n:::\n:::\n\n\n::: {#4c6ee928 .cell execution_count=20}\n``` {.python .cell-code}\n# Máscaras Booleanas\na = np.array([1, 2, 3, 4, 5])\nmask = a > 3\nprint(a[mask])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4 5]\n```\n:::\n:::\n\n\n::: {#c9ea1af0 .cell execution_count=21}\n``` {.python .cell-code}\na = np.array([5, 1, 2, 4, 3])\nprint(np.sort(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5]\n```\n:::\n:::\n\n\n::: {#23157bc3 .cell execution_count=22}\n``` {.python .cell-code}\na = np.array([1, 2, 2, 3, 3, 3])\nprint(np.unique(a))\nprint(np.bincount(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n[0 1 2 3]\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## *Operaciones Matemáticas*\n\n::: {#5fb4c7e1 .cell execution_count=23}\n``` {.python .cell-code}\n# Elemento x Elemento\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nprint(5 * a)\nprint(1 + a)\nprint(2 % a)\nprint(a + b)\nprint(a * b)\nprint(a / b)\nprint(np.sqrt(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 5 10 15]\n[2 3 4]\n[0 0 2]\n[5 7 9]\n[ 4 10 18]\n[0.25 0.4  0.5 ]\n[1.         1.41421356 1.73205081]\n```\n:::\n:::\n\n\n::: {#a6aa45b9 .cell execution_count=24}\n``` {.python .cell-code}\nb = np.append(b, [7]); print(a + b)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">ValueError</span>                                Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[24], line 1</span>\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 1</span> b <span style=\"color:rgb(98,98,98)\">=</span> np<span style=\"color:rgb(98,98,98)\">.</span>append(b, [<span style=\"color:rgb(98,98,98)\">7</span>]); <span style=\"color:rgb(0,135,0)\">print</span>(a <span style=\"color:rgb(98,98,98)\">+</span> b)\n\n<span class=\"ansi-red-fg ansi-bold\">ValueError</span>: operands could not be broadcast together with shapes (3,) (4,) </pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#6d0961e9 .cell execution_count=25}\n``` {.python .cell-code}\n# Funciones Agregadas\na = np.array([1, 2, 3, 4, 5])\nprint(f'''\n  np.sum(a) : { np.sum(a) }\n  np.mean(a): { np.mean(a) }\n  np.std(a) : { np.std(a) }\n  np.min(a) : { np.min(a) }\n  np.max(a) : { np.max(a) }\n''')\n# 2-D Arrays\nb = np.array([[1,2], [3,4], [5,6]])\nprint(b.sum(axis = None))\nprint(b.sum(axis = 0))\nprint(b.sum(axis = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  np.sum(a) : 15\n  np.mean(a): 3.0\n  np.std(a) : 1.4142135623730951\n  np.min(a) : 1\n  np.max(a) : 5\n\n21\n[ 9 12]\n[ 3  7 11]\n```\n:::\n:::\n\n\n::: {#dcfd61d7 .cell execution_count=26}\n``` {.python .cell-code}\n# Funciones con Matrices\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nprint(np.dot(a, b))\nprint(a.T) # Equivalente a -> .transpose()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[19 22]\n [43 50]]\n[[1 3]\n [2 4]]\n```\n:::\n:::\n\n\n::: {#7346a76b .cell execution_count=27}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nn_steps = 1000\nsteps = np.random.choice([-1, 1], n_steps)\nwalk = np.cumsum(steps)\n\nplt.plot(walk)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-28-output-1.png){width=578 height=411}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### *Otras*\n\n::: {#cb69a426 .cell execution_count=28}\n``` {.python .cell-code}\na = np.array([1, np.nan, np.inf, -np.inf, 5])\nprint(np.isnan(a))\nprint(np.isfinite(a))\nprint(np.isinf(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[False  True False False False]\n[ True False False False  True]\n[False False  True  True False]\n```\n:::\n:::\n\n\n::: {#64df27f4 .cell execution_count=29}\n``` {.python .cell-code}\na = np.array([1, np.nan, np.inf, -np.inf, 5])\nprint(np.nan_to_num(a)) # Reemplaza NaN con ceros y +/- inf con grandes números finitos.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 1.00000000e+000  0.00000000e+000  1.79769313e+308 -1.79769313e+308\n  5.00000000e+000]\n```\n:::\n:::\n\n\n### `np.where()`\n\nEs una función muy versátil y poderosa en NumPy que se utiliza para realizar operaciones basadas en condiciones lógicas. Su uso es esencial cuando se necesita aplicar lógica condicional a arreglos, y se vuelve aún más útil cuando se combina con Pandas para manipular DataFrames.\n\n::: {#cbf75996 .cell execution_count=30}\n``` {.python .cell-code}\na = np.array([1, -.1, 0, 1.2, -3.1])\nresult = np.where(a > 0, 1, 0)\nprint(result)\n\n# Obtener los índices donde se cumple:\nindices = np.where(a > 0)\nprint(indices)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 0 0 1 0]\n(array([0, 3], dtype=int64),)\n```\n:::\n:::\n\n\n::: {#61b978db .cell execution_count=31}\n``` {.python .cell-code}\nimport pandas as pd\n# DataFrame de ejemplo\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age' : [24, 17, 30, 50, 15],\n    'Amount': [88, 92, 79, 95, 70]\n}\ndf = pd.DataFrame(data)\n\ndf['Adult'] = np.where(df['Age'] >= 18, True, False)\ndf['Category'] = np.where(\n    df['Age'] < 18, 'Minor',\n    np.where(df['Age'] < 30, 'Young Adult', 'Adult')\n)\ndf['NewAmount'] = np.where(df['Adult'] == False, df['Amount']*0.5, df['Amount'])\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Name  Age  Amount  Adult     Category  NewAmount\n0    Alice   24      88   True  Young Adult       88.0\n1      Bob   17      92  False        Minor       46.0\n2  Charlie   30      79   True        Adult       79.0\n3    David   50      95   True        Adult       95.0\n4      Eva   15      70  False        Minor       35.0\n```\n:::\n:::\n\n\nBeneficios:\n\n-   **Eficiencia**: Es muy rápido porque realiza operaciones vectorizadas, aprovechando la eficiencia de NumPy.\n-   **Flexibilidad**: Permite aplicar lógica condicional compleja en una sola línea de código.\n-   **Compatibilidad**: Se integra perfectamente con Pandas, facilitando la manipulación de DataFrames.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}