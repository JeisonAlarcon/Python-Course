---
title:   "Data Manipulation P1"
date:    "2024-07-15"
image:   "Featured_Image_Numpy.jpg"
jupyter: python3
from:    markdown+emoji
categories: [Numpy, Pandas, Polars, Modin, Vaex, Datatable, CuPy]
---

[`NumPy`](https://numpy.org/doc/stable/user/index.html#user) es una biblioteca fundamental para la computación científica en Python. Proporciona soporte para arreglos y matrices multidimensionales, junto con una colección de funciones matemáticas para operar con estos arreglos.

```{python}
# pip install numpy
import numpy as np
```

------------------------------------------------------------------------

## *Creación de Arrays*

Básicamente, hay cuatro tipos numéricos en el código NumPy, y cada uno puede tener algunos tamaños diferentes.

| Name     | \# of Bits | Python Type | NumPy Type   |
|----------|------------|-------------|--------------|
| Integer  | 64         | int         | np.int\_     |
| Booleans | 8          | bool        | np.bool\_    |
| Float    | 64         | float       | np.float\_   |
| Complex  | 128        | complex     | np.complex\_ |

```{python}
# Unidimensionales
a = np.array([1, 2, 3, 4, 5], dtype = 'float64'); print(a); print(a.dtype)
```

```{python}
# Bidimensionales
b = np.array([[1, 2, 3], [4, np.NaN, 6]]); print(b)
print(f'''
  b.ndim : { b.ndim }
  b.shape: { b.shape }
  b.size : { b.size }
''')
```

```{python}
np.array(["lunes", "martes", "miercoles"], dtype = str).itemsize

data = np.array([
  ("joe", 32, 6),
  ("mary", 15, 20),
  ("felipe", 80, 100),
  ("beyonce", 38, 9001),
], dtype=[("name", str, 10), ("age", int), ("power", int)])

data[data["power"] > 9000]["name"]
np.sort(data[data["age"] > 20], order = "power")["name"]
```

------------------------------------------------------------------------

## *Arrays con Valores Iniciales Específicos*

```{python}
# Array de ceros
c = np.zeros((3, 4)); print(c)
```

```{python}
# Array de unos
d = np.ones((2, 3)); print(d)
```

```{python}
# Matriz identidad
e = np.eye(4); print(e)
```

```{python}
# Array de un valor constante
f = np.full((3, 3), 7); print(f)
```

```{python}
# Array con valores aleatorios
g = np.random.random((2, 2)); print(g)
```

```{python}
# Array de un rango de valores
h = np.arange(10, 20, 2); print(h)
print(np.arange(32).reshape(4, 1, 8))
```

```{python}
# Array con un número específico de valores igualmente espaciados
i = np.linspace(0, 1, 5); print(i)
```

------------------------------------------------------------------------

## *Manipulación de Arrays*

```{python}
a = np.array([1, 2, 3, 4, 5])
print(a[0])    # Primer elemento
print(a[1:3])  # Subarray del índice 1 al 2
print(a[-1])   # Último elemento
```

```{python}
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(a[1, 2])      # Elemento en la fila 1, columna 2
print(a[:, 1])      # Todas las filas, segunda columna
print(a[1:3, 1:3])  # Subarray desde la fila 1 a 2 y columna 1 a 2
```

```{python}
a = np.array([1, 2, 3, 4, 5])
a[0] = 10
print(a)
```

```{python}
a = np.array([1.1, 2.2])
a = np.append(a, [3.9, 4.6])
print(a)
```

```{python}
a = np.insert(a, 1, values = [1.8, 2.0]); print(a)
```

```{python}
a = np.delete(a, [1, 2]); print(a)
```

```{python}
a = np.array([[1, 2, 3], [4, 5, 6]])

print(a.ravel())          # Flatten the array
print(a.reshape((3, 2)))  # Reshape, but don’t change data
```

```{python}
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
c = np.concatenate((a, b), axis = None)
print(c)

# Dividir un array en múltiples subarrays
d = np.split(c, 3)
print(d)
```

```{python}
# Máscaras Booleanas
a = np.array([1, 2, 3, 4, 5])
mask = a > 3
print(a[mask])
```

```{python}
a = np.array([5, 1, 2, 4, 3])
print(np.sort(a))
```

```{python}
a = np.array([1, 2, 2, 3, 3, 3])
print(np.unique(a))
print(np.bincount(a))
```

------------------------------------------------------------------------

## *Operaciones Matemáticas*

```{python}
# Elemento x Elemento
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(5 * a)
print(1 + a)
print(2 % a)
print(a + b)
print(a * b)
print(a / b)
print(np.sqrt(a))
```

```{python}
b = np.append(b, [7]); print(a + b)
```

```{python}
# Funciones Agregadas
a = np.array([1, 2, 3, 4, 5])
print(f'''
  np.sum(a) : { np.sum(a) }
  np.mean(a): { np.mean(a) }
  np.std(a) : { np.std(a) }
  np.min(a) : { np.min(a) }
  np.max(a) : { np.max(a) }
''')
# 2-D Arrays
b = np.array([[1,2], [3,4], [5,6]])
print(b.sum(axis = None))
print(b.sum(axis = 0))
print(b.sum(axis = 1))
```

```{python}
# Funciones con Matrices
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])
print(np.dot(a, b))
print(a.T) # Equivalente a -> .transpose()
```

```{python}
import matplotlib.pyplot as plt
n_steps = 1000
steps = np.random.choice([-1, 1], n_steps)
walk = np.cumsum(steps)

plt.plot(walk)
plt.show()
```

------------------------------------------------------------------------

### *Otras*

```{python}
a = np.array([1, np.nan, np.inf, -np.inf, 5])
print(np.isnan(a))
print(np.isfinite(a))
print(np.isinf(a))
```

```{python}
a = np.array([1, np.nan, np.inf, -np.inf, 5])
print(np.nan_to_num(a)) # Reemplaza NaN con ceros y +/- inf con grandes números finitos.
```

### `np.where()`

Es una función muy versátil y poderosa en NumPy que se utiliza para realizar operaciones basadas en condiciones lógicas. Su uso es esencial cuando se necesita aplicar lógica condicional a arreglos, y se vuelve aún más útil cuando se combina con Pandas para manipular DataFrames.

```{python}
a = np.array([1, -.1, 0, 1.2, -3.1])
result = np.where(a > 0, 1, 0)
print(result)

# Obtener los índices donde se cumple:
indices = np.where(a > 0)
print(indices)
```

```{python}
import pandas as pd
# DataFrame de ejemplo
data = {
    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
    'Age' : [24, 17, 30, 50, 15],
    'Amount': [88, 92, 79, 95, 70]
}
df = pd.DataFrame(data)

df['Adult'] = np.where(df['Age'] >= 18, True, False)
df['Category'] = np.where(
    df['Age'] < 18, 'Minor',
    np.where(df['Age'] < 30, 'Young Adult', 'Adult')
)
df['NewAmount'] = np.where(df['Adult'] == False, df['Amount']*0.5, df['Amount'])

print(df)
```

Beneficios:

-   **Eficiencia**: Es muy rápido porque realiza operaciones vectorizadas, aprovechando la eficiencia de NumPy.
-   **Flexibilidad**: Permite aplicar lógica condicional compleja en una sola línea de código.
-   **Compatibilidad**: Se integra perfectamente con Pandas, facilitando la manipulación de DataFrames.
